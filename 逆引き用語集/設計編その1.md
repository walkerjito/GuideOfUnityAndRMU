# 設計について

僕が設計でつまづいた点についてメモをします。

<dl>
<dt>

## 逆引き用語

</dt>
<dd>

### その1

|目的|キーワード|
----|----|----
|視覚的にプログラムを表現したい|フローチャート|
|オブジェクトの役割の相関図を表現したい|クラス図|
|使っている、使われる|依存|
|インターフェイス継承|実現|

</dd>
</dl>

### 設計メモ

<dl>
<dt>
依存とは何か？
</dt>
<dd>

ソースコードにおいて、あるクラス User 内で、特定のクラス Attacker を使用することを依存すると言います。</br>
特定のクラス Attakcer を使用しているので、その Attakcker の仕様が変更された時には、使用元のクラス User で扱い方を変えなければいけません。

```
class User {
    var item = new Damager();
    item.Do();
}

class Damager {
    public void Do(){
            Damage(1);
    }

    private Damage(int value){
        Console.WriteLine("{0} point Damaged.")
    }
}
```

例えばこんなコードがあったとして、次のように変化します。

```
class Attacker {
    public void Do(){
        Attack(1);
    }

    private Attack(int value){
        Console.WriteLine("{0} point Attacked.");
    }
}
```

すると、Attacker.Do() の目的が変化しますので、Damager クラスの使用から、Attacker クラスの使用に変更するため、User クラスに修正を入れなければいけません。

```
class User {
    var item = new Attacker(); // Damager から Attacker に変更
    item.Do();
}
```

</br>
つまり、Damager クラスの変更に User クラスのソースコードが左右されてしまうと言う事です。
</br>
ですので、日本語の「依存」の意味そのままの意味で使われています。
プログラムをメタに考えた事のまだ少ない方はプログラム界隈で耳にし慣れない「依存」と言う言葉を聞き、パニックになってしまうかも知れませんが、日本語の依存のそのままの意味で使っています。落ち着いて関係を見直せば、「確かに依存している」ことは理解できることと思います。
</dd>

</br>

<dt>
依存性逆転とは何か
</dt>
<dd>
それでは設計を勉強すると出てくる依存性逆転とはなんでしょうか。
</br>
依存する場合、向きとして、前出の User クラスが Damager クラスに依存しています。先ほどの変更でも分かるように、User クラスが変更しても Damager クラスは変更しなくて良いからです。
</br>
しかし、プログラム開発の現場として有名な例えに、上司が部下の事を全て把握しなければならないとなると、上司は部下の数が増えれば増えるほど、負担が大きくなるというものがあります。
これと同じ事がプログラムのソースコードにも当てはまります。

以下の例では、ユーザーが使っているアプリを管理する例を上げます。
ユーザーは使うアプリの数が多ければ多いほど中身を把握しなければ使用することは出来ません。
つまりアプリの量が多ければ多いほど負担は増します。

```
class User {
    var acter01 = new Damager();
    var actor02 = new Attacker();
    var actor03 = new Dancer();
   // etc etc...

    actor01.Damage();
    actor02.Attack();
    actor03.Dance();
    // etc etc...
}
```

ユーザーはアプリに依存しているのです。

しかしこれを、Damager, Attacker, Dancer, Singer に共通するインターフェイスを実現させると、以下のようになります。

```
class User {
    List<IWorker> actors = new List<IWorker>();
    actors.Add(new Damager());
    actors.Add(new Attacker());
    actors.Add(new Dancer());

    foreach(var worker in actors){
        worker.Work();
    }
}

public interface IWorker {
    void Work();
}

public class Damager : IWorker{
    public void Work(){
        Console.WriteLine("Damaged.");
    }
}

public class Attacker : IWorker{
    public void Work(){
        Console.WriteLine("Attacked.");
    }
}

public class Dancer : IWorker{
    public void Work(){
        Console.WriteLine("Danced.");
    }
}

etc etc...

```

お分かりでしょうか。ユーザーは、アプリに共通の「仕事しろ！」の命令しか出来ませんが、アプリを使用する際に、個々の性格を把握する必要がなくなり、仕事が楽になりました。

その代わり、個々のポテンシャルを最大限に発揮できるかは不透明にはなるかと思いますが。

しかし、この例は少し力技の嫌いがあります。

もう一つの例を挙げてみます。

</dd>

```
class User {
    IDrawer tool = new AdobeIllustration();

    Work(tool);

    tool = new CorelDraw();

    Work(tool);

    private Work(IDrawer tool){
        tool.Draw();
        tool.Fill();
    }
}

IDrawer {
    void Draw();
    void Fill();
}

class AdobeIllustration : IDrawer{
    public Draw() {
        Console.WriteLine("draw with adobe illustration.");
    }

    public Fill() {
        Console.WriteLine("fill with adobe illustration.");
    }
}

class CorelDraw : IDrawer{
    public Draw() {
        Console.WriteLine("draw with corel draw.");
    }

    public Fill() {
        Console.WriteLine("fill with corel draw.");
    }
}

```

ユーザーは、illustration のスタイルの仕事をする IDrawer の作業が出来ます。仕事をする時に、IDrawer のアプリを選択するだけで同じように（実際には詳細が違うので全く同じには出来ませんが、似たような感覚で）同じ作業が出来ます。

こうすると、AdobeIllustration や CorelDraw の詳細に依存しておらず、IDrawer タイプのアプリなら同じように使えるため、IDrawer に依存している事になります。

すると、今度は、AdobeIllustration や CorelDraw は IDrawer を使える人に向けてアプリを売ろうとするので、アプリ側が IDrawer に依存するようになります。

詳細に依存していたユーザーと、ユーザーを意識せずに作っていたアプリに対して、今度は両者が IDrawer と言う抽象に対して依存しました。

しかし、このアプリがインターフェイスに依存する事に注目して、依存性の関係が逆転しているので、依存性逆転と言います。
</dl>